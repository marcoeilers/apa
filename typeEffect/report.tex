\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\headsep1cm
\parindent0cm
\usepackage{amssymb, amstext, amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{graphicx}
\usepackage{bussproofs}
%\usepackage{fullpage}
\usepackage{tikz}
\usepackage{listings}
\usepackage{mathtools}

\usepackage{hyperref}  
\newcommand{\wpe}[2]{\texttt{wp }#1\texttt{ }#2}
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}

\headsep1cm


\lstset{basicstyle=\footnotesize}
\usetikzlibrary{arrows,automata}

\lhead{\textbf{Project 2: Type and Effect Systems}}
\rhead{}

\cfoot{}
\lfoot{Marco Eilers, Bas in het Veld}
\rfoot{\thepage\ of \pageref{LastPage}}
\pagestyle{fancy}
\renewcommand{\footrulewidth}{0.4pt}

\setlength{\parskip}{4pt}

\begin{document}

\title{Automatic Program Analysis\\Project 2: Type and Effect Systems}
\author{Marco Eilers - F121763, Bas in het Veld - 3710971}

\maketitle

\section{Introduction}
We implemented a Control Flow Analysis for the \emph{FUN} language (described in the next section), extended with syntax for basic data structures. The analysis tracks the creation points of both functions and data structures, and is both polymorphic and polyvariant. Our implementation is written in Haskell. 

\section{Language to be Analyzed}

For our assignment, we decided to use the \emph{FUN} language, as described in \emph{Nielson, Nielson \& Hankin}, chapter 5.1.
The \emph{FUN} language is an untyped lambda calculus, with operators for recursion, and conditional and local definitions.
Program fragments with labels are \emph{expressions}, and program fragments without labels are \emph{terms}.
Below is a general overview of the syntax of this language:
\\
\\
\begin{tabular}{l l}
Expressions: &	$e \in \textbf{Exp}$ \\
Terms: &		$t \in \textbf{Term}$ \\
 & \\
Variables: &		$f,x \in \textbf{Var}$ \\
Constants &		$c \in \textbf{Const} $ \\
Binary operators &	$\oplus \in \textbf{Op} $ \\
Labels &		$\pi \in \textbf{Lab} $ \\
\end{tabular}
\\
\\
The \emph{abstract syntax} is:
\\
\\
\begin{tabular}{l}
$e ::= t_\pi$ \\
$t ::= c\:|\:x\:|\:\textbf{fn}\:x\:=>\:(e_0)\:|\:\textbf{fun}\:f\:x\:=>\:(e_0)\:|\:e_1\:e_2\:|$ \\
$\:\:\:\textbf{if}\:e_0\:\textbf{then}\:e_1\:\textbf{else}\:e_2\:|\:\textbf{let}\:x\:=\:e_1\:\textbf{in}\:e_2\:|\:e_1\:\oplus\:e_2\:|$\\
$\:\:\:\textbf{Pair}(e_1,\:e_2)\:|\: \textbf{case}\:e_0\:\textbf{of Pair}(x_1,\:x_2)\:=>\:e_1\:|$ \\
$\:\:\:\textbf{Nil}\:|\:\textbf{Cons}(e_1,\:e_2)\:|\:\textbf{case}\:e_0\:\textbf{of Cons}(x_1,\:x_2)\:=>\:e_1\:\textbf{or}\:e_2$ \\
$c ::= n\:|\:\textbf{true}\:|\:\textbf{false}$ \\
$\oplus ::= +\:|\:-\:|\:*\:|\:\&\&\:|\:||\:|\:<\:|\:>$
\end{tabular}
\\
\\
In this syntax, there are two distinct function definitions: $\text{fn}\:x\:=>\:(e_0)$ is a normal function definition, and $\text{fun}\:f\:x\:=>\:(e_0)$ is its recursive variant.
In the latter, any free occurrence of $f$ in $e_0$ refers to $\text{fun}\:f\:x\:=>\:(e_0)$.
Finally, $\text{let}\:x\:=\:e_1\:\text{in}\:e_2$ is a local definition. 

This concludes the original language described in NNH. Since we wanted to include data structures for our analyses, we added five more constructs. For pairs, we have the constructor $\textbf{Pair}(e_1,\:e_2)$, which creates a pair of two expressions, and the case statement $\textbf{case}\:e_0\:\textbf{of Pair}(x_1,\:x_2)\:=>\:e_1$, where $e_0$ must evaluate to a pair and $e_1$ may use the variables $x_1$ and $x_2$. The constructs for lists are similar. We have the constructors \textbf{Nil}, which creates an empty list, and $\textbf{Cons}(e_1,\:e_2)$, which prepends $e_1$ to the list $e_2$. Finally, we have the case statement $\textbf{case}\:e_0\:\textbf{of Cons}(x_1,\:x_2)\:=>\:e_1\:\textbf{or}\:e_2$, where $e_0$ must evaluate to a list, $e_1$ may refer to the variables $x_1$ and $x_2$ and is evaluated if $e_0$ evaluates to a non-empty list, and $e_2$ is evaluated if the list is empty (and may not refer to the variables).

While we were initially planning to include the possibility to add user-defined data structures, we decided to focus on the actual analysis first and finally had no time to add more features to the language.

We wrote our own parser for \emph{FUN}, which can be found in the file \texttt{FunParser.hs}. It works fine for most examples we tried, but since we did not want to spend too much time on the parser, it is not perfect. Therefore it is sometimes necessary to add seemingly superfluous parentheses around expressions (see for example the syntax for functions above). In particular, there must be parentheses around every function application. 

The data structures used for storing programs can be found in the file \texttt{AST.hs}.

\section{Control Flow Analysis}


\subsection{Annotated Type System}
We perform our analysis using an annotated type system that looks like this: TODO



\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\hat{\Gamma} \vdash_{CFA} n : Int$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\hat{\Gamma} \vdash_{CFA} \textbf{true} : Bool$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\hat{\Gamma} \vdash_{CFA} \textbf{false} : Bool$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\hat{\Gamma}(x) = \hat{\sigma}$}
\UnaryInfC{$\hat{\Gamma} \vdash_{CFA} x : \hat{\sigma}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\hat{\Gamma}[x \mapsto \hat{\tau_1}] \vdash_{CFA} t_1 : \hat{\tau_2}$}
\UnaryInfC{$\hat{\Gamma} \vdash_{CFA} \textbf{fn}_\pi \texttt{ }x => (t_1) : \hat{\tau_1} \xrightarrow{\{\pi\}}\hat{\tau_2}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\hat{\Gamma}[f \mapsto (\hat{\tau_1} \xrightarrow{\{\pi\}}\hat{\tau_2})][x \mapsto \hat{\tau_1}] \vdash_{CFA} t_1 : \hat{\tau_2}$}
\UnaryInfC{$\hat{\Gamma} \vdash_{CFA} \textbf{fun}_\pi \textbf{ }f \textbf{ }x => (t_1) : \hat{\tau_1} \xrightarrow{\{\pi\}}\hat{\tau_2}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_1 : \hat{\tau_2} \xrightarrow{\varphi} \hat{\tau}$}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_2 : \hat{\tau_2}$}
\BinaryInfC{$\hat{\Gamma} \vdash_{CFA} t_1 t_2 : \hat{\tau}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_1 : \hat{\sigma_1}$}
\AxiomC{$\hat{\Gamma}[x \mapsto \hat{\sigma_1}] \vdash_{CFA} t_2 : \hat{\tau}$}
\BinaryInfC{$\hat{\Gamma} \vdash_{CFA} \textbf{let }x = t_1 \textbf{ in } t_2 : \hat{\tau}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_1 : \tau_\oplus^1 $}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_2 : \tau_\oplus^2 $}
\BinaryInfC{$\hat{\Gamma} \vdash_{CFA} t_1 \oplus t_2 : \tau_\oplus$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_0 : \textbf{ } Bool$}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_1 : \hat{\tau}$}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_2 : \hat{\tau}$}
\TrinaryInfC{$\hat{\Gamma} \vdash_{CFA} \textbf{if } t_0 \textbf{ then }t_1 \textbf{ else } t_2 : \hat{\tau}$}
\end{prooftree}


\begin{prooftree}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_1 : \hat{\tau_1}$}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_2 : \hat{\tau_2}$}
\BinaryInfC{$\hat{\Gamma} \vdash_{CFA} \textbf{Pair}_\pi(t_1, t_2) : (\hat{\tau_1} \times^{\{\pi\}} \hat{\tau_2})$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_1 : \hat{\tau}$}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_1 : \hat{\tau} \textbf{ }list^{\varphi}$}
\BinaryInfC{$\hat{\Gamma} \vdash_{CFA} \textbf{Cons}_\pi(t_1, t_2) :  \hat{\tau} \textbf{ }list^{\{\pi\}}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\hat{\Gamma} \vdash_{CFA} \textbf{Nil}_\pi : \forall \alpha. \alpha \textbf{ } list^{\{\pi\}}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_0 : (\hat{\tau_1} \times^\varphi \hat{\tau_2}) $}
\AxiomC{$\hat{\Gamma}[x_1 \mapsto \hat{\tau_1}][x_2 \mapsto \hat{\tau_2}] \vdash_{CFA} t_1 : \hat{\tau}$}
\BinaryInfC{$\hat{\Gamma} \vdash_{CFA} \textbf{case } t_0 \textbf{ of Pair}(x_1, x_2) => t_1 : \hat{\tau}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_0 : \hat{\tau_0} \textbf{ }list^\varphi$}
\AxiomC{$\hat{\Gamma}[x_1 \mapsto \hat{\tau_0}][x_2 \mapsto \hat{\tau_0}\textbf{ }list^\varphi ] \vdash_{CFA} t_1 : \hat{\tau}$}
\AxiomC{$\hat{\Gamma} \vdash_{CFA} t_2 : \hat{\tau}$}
\TrinaryInfC{$\hat{\Gamma} \vdash_{CFA} \textbf{case }t_0 \textbf{ of Cons}(x_1, x_2) => t_1 \textbf{ or }t_2 : \hat{\tau}$}
\end{prooftree}

\subsection{Algorithm}
Our algorithm is a modified version of Algorithm W as used in NNH. 

TODO

\subsection{Implementation}
The implementation of the algorithm can be found in the file \texttt{ControlFlowAnalysis.hs}. 

TODO

\subsection{Polyvariance}


\section{Evaluation of our Solution}


\section{Compiling and Running our Code}


\section{Example Programs and Results}


\end{document}
